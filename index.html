<!doctype html>
<html><head><meta charset="utf-8" />
<title>Isomorphic Artwork</title>
<style>
  .box {
    height: 30px;
    width: 30px;
    position: absolute;
  }
  #pc {
    height: 50px;
    width: 50px;
    position: absolute;
    background-color: hsla(0, 100%, 100%, 0.8); 
  }
  #stack {
    position: absolute;
    top: 500px;
  }
  #rstack {
    position: absolute;
    top: 530px;
  }
  #legend {
    position: absolute;
    top: 560px;
  }
</style>
</head><body>
  
  <div id="bottom"></div>
  <div id="pc"></div>

  <div id="stack"></div>
  <div id="rstack"></div>
  
  <div id="legend">Isomorphic Artwork -- a tiny stack machine by dann</div>
  
  
<script>
  
  var  stack  = []                                      // parameter stack
  var rstack  = []                                      // return stack
  var memory  = []                                      // TODO: make this a byte array
  
  var codes   = []                                      // TODO: make this a byte array
  var pc      = -1                                      // program counter
  var vdom    = {}                                      // virtual dom

  var bottom  = document.getElementById('bottom')       // divs are appended above this
  var highlight = document.getElementById('pc')         // divs are appended above this
  vdom['highlight'] = {el: highlight, color: 0}
  
  var el_stack = document.getElementById('stack')       // divs are appended above this
  var el_rstack = document.getElementById('rstack')     // divs are appended above this

  
  var magic_offset = 10
  
  function reset() {
    pc = -1
    stack  = []
    rstack = []
    memory = resize(memory, 256)
  }
  
  function run(program) {
    reset()
    codes = compile(program) // OPT
    while(step(pc++) !== false) {}
  }
  
  function slowrun(program, done) {
    reset()
    codes = compile(program) // OPT
    codes = resize(codes, 256)
    
    function loop() {
      draw_memory(memory)
      draw_codes(codes)
      draw_highlight(pc)
      draw_saturation(pc, true)
      draw_stacks()
      
      if(step(pc++) !== false)
        window.requestAnimationFrame(loop)
      else
        if(typeof done == 'function') done()
    }
    window.requestAnimationFrame(loop)
  }
  
  function rando(done) {
    hack_dict()
    memory  = randfill(256)
    program = randfill(256)
    slowrun(program, done)
  }
  
  function hack_dict() {
    dict['M>1'] = dict['M>']
    dict['M>2'] = dict['M>']
    dict['M>3'] = dict['M>']
    dict['M>4'] = dict['M>']
    dict['M>5'] = dict['M>']
    dict['M>6'] = dict['M>']
    dict['M>7'] = dict['M>']
    dict['M>8'] = dict['M>']
    dict['M>9'] = dict['M>']
    dict['M>a1'] = dict['M>']
    dict['M>a2'] = dict['M>']
    dict['M>a3'] = dict['M>']
    dict['M>a4'] = dict['M>']
    dict['M>a5'] = dict['M>']
    dict['M>a6'] = dict['M>']
    dict['M>a7'] = dict['M>']
    dict['M>a8'] = dict['M>']
    dict['M>a9'] = dict['M>']

    dict['jump1'] = dict['jump']
    dict['jump2'] = dict['jump']
    
    var old_exit = dict['exit']
    dict['exit'] = function() {
      var out = old_exit()
      // dehighlight back to new pc
      for(var i = codes.length - 1; i >= pc; i--) {
        draw_saturation(i, false)
      }
      return out
    }
  }
  
  function clone(arr) {
    return JSON.parse(JSON.stringify(arr))
  }
  
  function randfill(size) {
    var arr = []
    for(var i = 0; i < size; i++)
      arr.push(Math.floor(Math.random()*256))
    return arr
  }
  
  function step() {
    var code = codes[pc]
    if(code == null) return false
    var maybe_word = code_to_word(code)
    if(maybe_word)
      return dict[maybe_word]()
    else
      push(code)
  }
  
  function scan_to_sub(how_far) {
    // TODO: do it more if needed
    //  % 4 // NOTE: 4 is magic
    var addr = next_exit(pc)
    if(!addr) return false                              // cause 0 addr would be silly
    return addr
  }
  
  function next_exit(offset) {
    for(var i = offset+1; i < codes.length; i++)        // +1 for luck
      if(code_to_word(codes[i]) == 'exit')
        return i
  }
  
  function push(val) {
    stack.push( +val || 0 )
  }
  
  function pop() {
    return stack.pop()
  }
  
  function read(addr) {
    return memory[addr] | 0
  }
  
  function write(addr, val) {
    if(addr < 0) addr = 0
    if(addr >= memory.length) addr = memory.length - 1
    memory[addr] = (val | 0) % 255 // memory values are constrained
  }
  
  function resize(arr, size) {
    if(arr.length > size) 
      return arr.slice(0, size)
    
    arr = arr.slice()
    for(var i = arr.length; i < size; i++)
      arr.push(0)

    return arr
  }
  
  // COMPILER
  
  function word_to_code(word) {
    var dict_keys = Object.keys(dict)
    var index = dict_keys.indexOf(word)
    if(index == -1) return false
    return index
  }
  
  function code_to_word(code) {
    var dict_keys = Object.keys(dict)
    var numkeys = dict_keys.length
    var size = magic_offset + numkeys
    var index = (code % size) - magic_offset
    if(index < 0) return false
    return dict_keys[index]
  }
  
  function compile(program) {
    return program.map(function(word) {
      if(word == +word) return word
      var maybe_code = word_to_code(word)
      if(maybe_code === false) return 0
      return maybe_code + magic_offset
    })
  }
  
  function decompile(bytecode) {
    return bytecode.map(function(code) {
      var maybe_word = code_to_word(code)
      if(maybe_word === false) return code
      return maybe_word
    })
  }
  
  
  // RENDERER
  
  function draw_memory(arr) {
    var nick = 'memory'
    var hoff = 500
    var voff = 0
    var wrap = 16
    var width = 30
    var height = 30
    
    for(var i = 0; i < arr.length; i++) {
      var x = width * (i % wrap) + hoff
      var y = height * (Math.floor(i/wrap)) + voff
      var color = arr[i]
      draw(color, x, y, i + nick)
    }
  }
  
  function draw_codes(arr) {
    var nick = 'codes'
    var hoff = 0
    var voff = 0
    var wrap = 16
    var width = 30
    var height = 30
    
    for(var i = 0; i < arr.length; i++) {
      var x = width * (i % wrap) + hoff
      var y = height * (Math.floor(i/wrap)) + voff
      var color = arr[i]
      draw(color, x, y, i + nick)
    }
  }
  
  function draw_highlight(pc) {
    var hoff = -10
    var voff = -10
    var wrap = 16
    var width = 30
    var height = 30
    var x = width * (pc % wrap) + hoff
    var y = height * (Math.floor(pc/wrap)) + voff
    
    draw(0, x, y, 'highlight')
  }
  
  function draw_saturation(pc, flag) {
    var nick = 'codes'
    var hoff = 0
    var voff = 0
    var wrap = 16
    var width = 30
    var height = 30
    
    var x = width * (pc % wrap) + hoff
    var y = height * (Math.floor(pc/wrap)) + voff
    var name = pc + nick
    
    var cell = vdom[name]
    if(!cell) return false
    
    color = cell.color
    draw(color, x, y, name, flag)
  }
  
  function draw_stacks() {
    el_stack.innerText = 'Stack: ' + stack.slice(-40)
    el_rstack.innerText = 'Return stack: ' + rstack.map(function(item) {return item[1]})
  }
  
  function draw(color, x, y, name, sat_flag) {
    var base_sat = 40
    var full_sat = 100
    var sat = sat_flag ? full_sat : base_sat
    var lit = 70
    
    var cell = vdom[name]
    
    if(!cell) {
      cell = {x: 'asdf', y: 'asdf', color: 'asdf', sat_flag: sat_flag}
      cell.el = document.createElement("div")
      cell.el.classList.add('box')
      document.body.insertBefore(cell.el, bottom); 
      vdom[name] = cell
    }
    
    if(cell.x != x) {
      cell.x = x
      cell.el.style.left = '' + x + 'px'
    }
    
    if(cell.y != y) {
      cell.y = y
      cell.el.style.top = '' + y + 'px'
    }
    
    if(cell.color != color || cell.sat_flag != sat_flag) {
      var webcolor
      cell.color = color
      if(code_to_word(color))
        webcolor = 'hsl('+ (color ? color : 300) +', '+ sat +'%, '+ lit +'%)'
      else
        webcolor = 'hsl(0, 0%, ' + Math.floor((sat_flag ? 70 : 40) + ((color*13) % 40)) + '%)'
      cell.el.style.backgroundColor = webcolor
    }
  }
  
  
  // DICTIONARY
  
  var dict = {}
  dict['+']    = function() {var x = pop(); push((pop() + x) | 0)}
  dict['-']    = function() {var x = pop(); push((pop() - x) | 0)}
  dict['*']    = function() {var x = pop(); push((pop() * x) | 0)}
  dict['/']    = function() {var x = pop(); push((pop() / x) | 0)}
  
  dict['>M']   = function() {var addr = pop(); var value = pop(); write(addr, value)}
  dict['M>']   = function() {var addr = pop(); push(read(addr))}
                 
  dict['abs' ] = function() {push(Math.abs(pop()))}
  dict['max' ] = function() {push(Math.max(pop(), pop()))}
  dict['min' ] = function() {push(Math.min(pop(), pop()))}
  
  dict['drop'] = function() {pop()}
  dict['pick'] = function() {var p=pop(); push(stack[stack.length-p-1])}
  dict['roll'] = function() {var p=pop(); var x=stack[stack.length-p-1]; stack.splice(stack.length-p-1, 1); push(x)}

  dict['dup'] = function() {push(stack[stack.length-1])} // TODO: remove this later

  dict['jump'] = function() {
    var index = pop()
    var how_far = pop()
    
    var addr = scan_to_sub(how_far)
    if(!addr) return dict['exit']()                     // YOLO
    
    index = index % 2 // more fun
    
    var triple = [pc, index, addr]
    rstack.push(triple)
    push(index)
    
    pc = addr
  } 
  
  dict['exit'] = function() {
    if(!rstack.length) return false                     // stop execution
    
    var triple = rstack.pop()
    var return_addr   = triple[0] || 0
    var current_index = triple[1] || 0
    var self_addr     = triple[2] || 0
      
    if(current_index < 1) { // THINK: -1 ?
      pc = return_addr                                  // all done!
    } else {
      current_index--
      push(current_index)
      rstack.push([return_addr, current_index, self_addr])
      pc = self_addr
    }
  }
  
  
  // TESTS
  
  run([1, 2, 3, 4, '+', '*', '+'])
  if(stack[0] != 15 || !stack.length) console.error('ASDF!')
  
  memory  = [50, 0, 100, 200, 0, 0, 0, 100, 50, 0, 0]
  program = [ 10, 'jump', 'exit'  // loop sub 10 times
            , 'dup', 'dup'        // copy loop index twice
            , 1, '-'              // take one less than loop index
            , 'M>', 1, 'pick'     // grab from mem, pick loop index
            , 'M>'                // grab from mem
            , '+', 2, '/'         // average neighbors
            , 'dup', 2, 'roll'    // dup value, swap positions for >M
            , '>M'                // put it back in memory at loop index
            , 1, 'roll'           // value then address
            , 1, '-', '>M'        // put it back in memory at loop index minus one
            , 'exit']             // return from sub

  run(program)
  if(JSON.stringify(memory.slice(0, 11)) != '[25,50,50,101,103,7,15,31,62,25,0]') console.error('QWERTY!')
  if(JSON.stringify(stack)  != '[]') console.error('YO!')
  
  if(JSON.stringify(compile(program)) != JSON.stringify(compile(compile(program)))) console.error('WOW!')
  
  if(JSON.stringify(decompile(compile(program))) != '[10,"jump","exit","dup","dup",1,"-","M>",1,"pick","M>","+",2,"/","dup",2,"roll",">M",1,"roll",1,"-",">M","exit"]') console.error('OOPS!')
  
  
  var old_memory = clone(memory)
  rando(function looper() {
    var repeat = JSON.stringify(old_memory) == JSON.stringify(memory)
    old_memory = clone(memory)
    if(repeat)
      rando(looper)
    else
      slowrun(memory, looper)
  })
  
  
  /* 
    next steps:
    -- fix step() to eat codes
    -- fix memory size before running
    -- visualize memory 
    -- step using window.requestAnimationFrame
    -- visualize program execution
    - change jump to take two params: count and skip. skip == 0 is no jump (conditional branching)
    - iterate program: (F(F))(F(F)) etc. e.g. F = F(F)
    - wrap subroutines nicely
    
  */
  
</script>
</body></html>