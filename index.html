<!doctype html>
<html><head><meta charset="utf-8" />
<title>Art Makes Programs</title>
<style></style>
</head><body>
  
<div id="left" style="float:left; margin-right:100px"></div>

<div id="right" style="float:left"></div>

<script>
  
  var  stack  = []                                      // parameter stack
  var rstack  = []                                      // return stack
  var memory  = []                                      // TODO: make this a byte array
  
  var codes   = []                                      // TODO: make this a byte array
  var pc      = -1                                      // program counter
  var vdom    = {}                                      // virtual dom
  
  left = document.getElementById('left')
  right = document.getElementById('right')
  
  function reset() {
    pc = -1
    stack  = []
    rstack = []
    memory = resize(memory, 256)
  }
  
  function run(program) {
    reset()
    codes = compile(program) // OPT
    while(step(pc++) !== false) {}
  }
  
  function slowrun(program) {
    reset()
    codes = compile(program) // OPT
    
    function loop() {
      draw(memory, right)
      draw(codes, left)
      
      if(step(pc++) !== false)
        window.requestAnimationFrame(loop)
    }
    window.requestAnimationFrame(loop)
  }
  
  function step() {
    var code = codes[pc]
    if(code == null) return false
    var maybe_word = code_to_word(code)
    if(maybe_word)
      return dict[maybe_word]()
    else
      push(code)
  }
  
  function scan_to_sub(how_far) {
    // TODO: do it more if needed
    //  % 4 // NOTE: 4 is magic
    var addr = next_exit(pc)
    if(!addr) return false                              // cause 0 addr would be silly
    return addr
  }
  
  function next_exit(offset) {
    for(var i = offset+1; i < codes.length; i++)        // +1 for luck
      if(code_to_word(codes[i]) == 'exit')
        return i
  }
  
  function push(val) {
    stack.push( +val )
  }
  
  function pop() {
    return stack.pop()
  }
  
  function read(addr) {
    return memory[addr] | 0
  }
  
  function write(addr, val) {
    if(addr < 0) addr = 0
    if(addr >= memory.length) addr = memory.length - 1
    memory[addr] = (val | 0) % 255 // memory values are constrained
  }
  
  function resize(arr, size) {
    if(arr.length > size) 
      return arr.slice(0, size)
    
    arr = arr.slice()
    for(var i = arr.length; i < size; i++)
      arr.push(0)

    return arr
  }
  
  // COMPILER
  
  function word_to_code(word) {
    var index = dict_keys.indexOf(word)
    if(index == -1) return false
    return index
  }
  
  function code_to_word(code) {
    var index = code - magic_offset
    if(index < 0 || index > dict_keys.length) return false
    return dict_keys[index]
  }
  
  function compile(program) {
    return program.map(function(word) {
      if(word == +word) return word
      var maybe_code = word_to_code(word)
      if(maybe_code === false) return 0
      return maybe_code + magic_offset
    })
  }
  
  function decompile(bytecode) {
    return bytecode.map(function(code) {
      var maybe_word = code_to_word(code)
      if(maybe_word === false) return code
      return maybe_word
    })
  }
  
  
  // RENDERER
  
  function draw(arr, el) {
    if(arr.length != 256) 
      arr = resize(arr, 256)
    
    var html = '<table>'
    
    for(var y = 0; y < 16; y++) {
      html += '<tr>'
      for(var x = 0; x < 16; x++) {
        var index = x + y * 16
        var value = arr[index]
        html += '<td style="width:20px; height:20px; background-color: hsl(' + (value?value:300) + ', 70%, 80%)">' + value + '</td>'
      }
      html += '</tr>'
    }
    
    html += '</table>'
    el.innerHTML = html
  }
  
  
  // DICTIONARY
  
  var dict = {}
  dict['+']    = function() {var x = pop(); push((pop() + x) | 0)}
  dict['-']    = function() {var x = pop(); push((pop() - x) | 0)}
  dict['*']    = function() {var x = pop(); push((pop() * x) | 0)}
  dict['/']    = function() {var x = pop(); push((pop() / x) | 0)}
  
  dict['>M']   = function() {var addr = pop(); var value = pop(); write(addr, value)}
  dict['M>']   = function() {var addr = pop(); push(read(addr))}
                 
  dict['abs' ] = function() {push(Math.abs(pop()))}
  dict['max' ] = function() {push(Math.max(pop(), pop()))}
  dict['min' ] = function() {push(Math.min(pop(), pop()))}
  
  dict['drop'] = function() {pop()}
  dict['pick'] = function() {var p=pop(); push(stack[stack.length-p-1])}
  dict['roll'] = function() {var p=pop(); var x=stack[stack.length-p-1]; stack.splice(stack.length-p-1, 1); push(x)}

  dict['dup'] = function() {push(stack[stack.length-1])} // TODO: remove this later

  dict['jump'] = function() {
    var index = pop()    
    var how_far = pop()
    
    var addr = scan_to_sub(how_far)
    if(!addr) return dict['exit']()                     // YOLO
    
    var triple = [pc, index, addr]
    rstack.push(triple)
    stack.push(index)
    
    pc = addr
  } 
  
  dict['exit'] = function() {
    if(!rstack.length) return false                     // stop execution
    
    var triple = rstack.pop()
    var return_addr   = triple[0]
    var current_index = triple[1]
    var self_addr     = triple[2]
      
    if(!current_index) { // THINK: -1 ?
      pc = return_addr                                  // all done!
    } else {
      current_index--
      push(current_index)
      rstack.push([return_addr, current_index, self_addr])
      pc = self_addr
    }
  }
  
  var magic_offset = 100
  var dict_keys = Object.keys(dict)
  
  
  // TESTS
  
  run([1, 2, 3, 4, '+', '*', '+'])
  if(stack[0] != 15 || !stack.length) console.error('ASDF!')
  
  memory  = [50, 0, 100, 200, 0, 0, 0, 100, 50, 0, 0]
  program = [ 10, 'jump', 'exit'  // loop sub 10 times
            , 'dup', 'dup'        // copy loop index twice
            , 1, '-'              // take one less than loop index
            , 'M>', 1, 'pick'     // grab from mem, pick loop index
            , 'M>'                // grab from mem
            , '+', 2, '/'         // average neighbors
            , 'dup', 2, 'roll'    // dup value, swap positions for >M
            , '>M'                // put it back in memory at loop index
            , 1, 'roll'           // value then address
            , 1, '-', '>M'        // put it back in memory at loop index minus one
            , 'exit']             // return from sub

  run(program)
  if(JSON.stringify(memory.slice(0, 11)) != '[25,50,50,101,103,7,15,31,62,25,0]') console.error('QWERTY!')
  if(JSON.stringify(stack)  != '[]') console.error('YO!')
  
  if(JSON.stringify(compile(program)) != JSON.stringify(compile(compile(program)))) console.error('WOW!')
  
  if(JSON.stringify(decompile(compile(program))) != '[10,"jump","exit","dup","dup",1,"-","M>",1,"pick","M>","+",2,"/","dup",2,"roll",">M",1,"roll",1,"-",">M","exit"]') console.error('OOPS!')
  

  
  /* 
    next steps:
    -- fix step() to eat codes
    -- fix memory size before running
    -- visualize memory 
    -- step using window.requestAnimationFrame
    - visualize program execution
    - change jump to take two params: count and skip. skip == 0 is no jump (conditional branching)
    - iterate program: (F(F))(F(F)) etc. e.g. F = F(F)
    - wrap subroutines nicely
    
  */
  
</script>
</body></html>